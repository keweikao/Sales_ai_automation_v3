# P0 優先級功能實作計畫

**規劃日期**: 2026-01-21
**預估總工時**: 35 小時（約 1.5 週）
**目標**: 完成監控體系、Alert 系統優化、跟進自動化執行機制

---

## 背景說明

基於系統探索結果，當前狀態：

### 已完成
- ✅ Beauty Bot 部署（包含 API_TOKEN）
- ✅ 健康檢查端點（/health, /ready, /live）
- ✅ Alert 系統核心功能（3 個規則、API、Web UI）
- ✅ 跟進資料庫 Schema 和排程建立邏輯
- ✅ Cloudflare Observability 啟用

### P0 需完成
1. **Alert 系統重新設計** - 根據業務反饋調整規則，新增定期評估機制
2. **跟進自動化執行 Worker** - 實作發送已排程跟進的機制
3. **Cloudflare Analytics 設定** - 建立自訂指標和告警規則

---

## 一、Alert 系統重新設計（16 小時）

### 1.1 業務需求收集（2 小時）

**目標**: 訪談業務團隊，調整規則參數

**訪談問題清單**:
1. Close Now 規則：80 分門檻是否太高？建議調整為多少？
2. Missing DM 規則：2 次對話後警示是否太早？
3. Manager Escalation 規則：連續 3 次低於 40 分是否合理？
4. 商機停滯：幾天沒聯絡算停滯？（7/14/30 天）
5. 高價值商機：如何定義？（分數/產品線/客戶規模）

**驗收**: 完成業務需求文檔

### 1.2 Schema 更新（1 小時）

**修改檔案**: [/packages/db/src/schema/alert.ts](packages/db/src/schema/alert.ts)

```typescript
export type AlertType =
  | "close_now"
  | "missing_dm"
  | "manager_escalation"
  | "opportunity_stale"      // 新增
  | "high_value_opportunity"; // 新增
```

**執行 Migration**:
```bash
cd packages/db
bun run db:generate
bun run db:migrate
```

**驗收**: Migration 成功，新 AlertType 可用

### 1.3 規則重新設計（3 小時）

**修改檔案**: [/packages/services/src/alerts/rules.ts](packages/services/src/alerts/rules.ts)

#### 調整現有規則
1. **Close Now**: 降低門檻 80→70，Champion 4→3
2. **Missing DM**: 對話次數 2→3，新增最近活躍檢查
3. **Manager Escalation**: 新增極低分快速警示(<30)、無進展警示

#### 新增規則
4. **Opportunity Stale**（商機停滯）
   - 條件：14 天未聯絡 + MEDDIC ≥ 50 + 活躍狀態
   - 嚴重程度：依停滯時間動態調整

5. **High Value Opportunity**（高價值追蹤）
   - 條件：MEDDIC ≥ 70 + Decision Process ≥ 3 + 3 天未聯絡
   - 提醒：定期跟進

**程式碼範例**:
```typescript
const opportunityStaleRule: AlertRule = {
  type: "opportunity_stale",
  name: "商機停滯",
  evaluate: (ctx) => {
    const daysSinceLastContact = Math.floor(
      (Date.now() - ctx.lastContactedAt.getTime()) / (1000 * 60 * 60 * 24)
    );

    const isStale = daysSinceLastContact >= 14;
    const isWorthFollowUp = ctx.meddicAnalysis.overallScore >= 50;
    const activeStatuses = ["contacted", "qualified", "proposal", "negotiation"];

    if (isStale && isWorthFollowUp && activeStatuses.includes(ctx.opportunityStatus)) {
      return {
        type: "opportunity_stale",
        severity: daysSinceLastContact >= 30 ? "high" : "medium",
        title: "商機停滯警示",
        message: `已 ${daysSinceLastContact} 天未聯絡，建議盡快跟進`,
        context: {
          meddicScore: ctx.meddicAnalysis.overallScore,
          triggerReason: `${daysSinceLastContact} 天未聯絡`,
          suggestedAction: "安排跟進會議，瞭解客戶近況",
        },
      };
    }
    return null;
  },
};
```

**驗收**: 5 個規則都通過 TypeScript 編譯

### 1.4 EvaluationContext 更新（1 小時）

**修改檔案**: [/packages/services/src/alerts/types.ts](packages/services/src/alerts/types.ts)

```typescript
export interface EvaluationContext {
  // ... 現有欄位 ...
  opportunityStatus: string;      // 新增
  lastContactedAt: Date | null;   // 新增
}
```

**修改檔案**: [/packages/services/src/alerts/evaluator.ts](packages/services/src/alerts/evaluator.ts)

更新 `buildEvaluationContext` 函數，包含新欄位。

**驗收**: TypeScript 無錯誤

### 1.5 Scheduled Alert Evaluator（4 小時）

**新增檔案**: [/apps/queue-worker/src/scheduled/alert-evaluator.ts](apps/queue-worker/src/scheduled/alert-evaluator.ts)

**核心功能**:
```typescript
export async function runAlertEvaluation(config: AlertEvaluatorConfig) {
  // 1. 取得所有活躍商機（排除 won/lost）
  const activeOpportunities = await db
    .select()
    .from(opportunities)
    .where(inArray(opportunities.status, ["new", "contacted", "qualified", "proposal", "negotiation"]));

  // 2. 逐一評估
  for (const opportunity of activeOpportunities) {
    const context = await buildEvaluationContext(opportunity.id);

    // 3. 評估所有規則
    for (const rule of ALERT_RULES) {
      const result = rule.evaluate(context);

      if (result) {
        // 4. 去重邏輯：24 小時內同類型不重複
        const recentAlert = await db.query.alerts.findFirst({
          where: and(
            eq(alerts.opportunityId, opportunity.id),
            eq(alerts.type, result.type),
            gte(alerts.createdAt, new Date(Date.now() - 24 * 60 * 60 * 1000))
          ),
        });

        if (!recentAlert) {
          // 5. 建立警示並發送 Slack 通知
          await createAlert(result);
        }
      }
    }
  }
}
```

**驗收**: 可單獨測試並成功產生警示

### 1.6 整合到 Queue Worker（2 小時）

**修改檔案**: [/apps/queue-worker/wrangler.toml](apps/queue-worker/wrangler.toml)

```toml
[triggers]
crons = ["*/30 * * * *"]  # 每 30 分鐘執行
```

**修改檔案**: [/apps/queue-worker/src/index.ts](apps/queue-worker/src/index.ts)

```typescript
export default {
  async queue(/* ... */) { /* 現有邏輯 */ },

  async scheduled(event: ScheduledEvent, env: Env) {
    const now = new Date();
    const currentHour = now.getHours();

    // 每 30 分鐘：Follow-up Executor
    await runFollowUpExecution({ /* ... */ });

    // 每 6 小時：Alert Evaluator（0:00, 6:00, 12:00, 18:00）
    if (currentHour % 6 === 0) {
      await runAlertEvaluation({ /* ... */ });
    }
  },
};
```

**驗收**: 部署後 cron 正常觸發，logs 顯示評估過程

### 1.7 測試和調整（3 小時）

**測試案例**:
1. 建立高分商機 (MEDDIC 70+) → 觸發 Close Now
2. 建立低分商機 (連續 3 次 <40) → 觸發 Manager Escalation
3. 建立停滯商機 (14 天未聯絡) → 觸發 Opportunity Stale
4. 建立高價值商機 (MEDDIC 70+, 3 天未聯絡) → 觸發 High Value
5. 驗證去重邏輯（24 小時內不重複）
6. 驗證 Slack 通知格式

**驗收**: 所有 5 個規則正確觸發並通知

---

## 二、跟進自動化執行 Worker（9 小時）

### 2.1 Follow-up Executor（3 小時）

**新增檔案**: [/apps/queue-worker/src/scheduled/follow-up-executor.ts](apps/queue-worker/src/scheduled/follow-up-executor.ts)

**核心功能**:
```typescript
export async function runFollowUpExecution(config: FollowUpExecutorConfig) {
  // 1. 查詢待執行的跟進
  const pendingFollowUps = await db.query.followUps.findMany({
    where: and(
      eq(followUps.status, "pending"),
      lte(followUps.scheduledAt, new Date())
    ),
    limit: 100,
  });

  // 2. 初始化 Slack Client
  const slackClient = new WebClient(config.slackBotToken);

  // 3. 逐一執行
  for (const followUp of pendingFollowUps) {
    try {
      let sent = false;

      if (followUp.channel === "slack_dm") {
        sent = await sendSlackDM(slackClient, followUp, config.webAppUrl);
      } else if (followUp.channel === "slack_channel") {
        sent = await sendSlackChannel(slackClient, followUp, config.webAppUrl);
      }

      // 4. 更新狀態為 sent
      if (sent) {
        await db.update(followUps)
          .set({ status: "sent", sentAt: new Date() })
          .where(eq(followUps.id, followUp.id));
      }
    } catch (error) {
      // 5. 更新狀態為 failed
      await db.update(followUps)
        .set({ status: "failed", errorMessage: error.message })
        .where(eq(followUps.id, followUp.id));
    }
  }
}
```

**Slack 訊息格式**:
```typescript
async function sendSlackDM(client, followUp, webAppUrl) {
  await client.chat.postMessage({
    channel: followUp.userId,
    blocks: [
      { type: "header", text: "⏰ 跟進提醒" },
      { type: "section", text: followUp.message },
      followUp.talkTrack && { type: "section", text: `*建議話術：*\n${followUp.talkTrack}` },
      { type: "actions", elements: [
        { type: "button", text: "查看商機", url: opportunityUrl, style: "primary" }
      ]},
    ],
  });
}
```

**驗收**: 可單獨測試並成功發送 Slack 訊息

### 2.2 整合和狀態管理（4 小時）

**整合到 Queue Worker**（已在 1.6 完成）:
- scheduled handler 每 30 分鐘執行 `runFollowUpExecution`
- Alert Evaluator 每 6 小時執行

**狀態管理**:
- pending → sent (成功發送)
- pending → failed (發送失敗，記錄 errorMessage)

**環境變數** (`wrangler.toml`):
```toml
[vars]
WEB_APP_URL = "https://your-web-app.pages.dev"
```

**驗收**:
- 狀態正確更新
- 錯誤能正確記錄

### 2.3 測試和驗證（2 小時）

**測試案例**:
1. 建立 Slack DM 跟進（scheduledAt: 1 分鐘後）
2. 建立 Slack Channel 跟進
3. 測試失敗情況（錯誤的 channel ID）
4. 驗證 Talk Track 和商機連結顯示
5. 驗證狀態更新

**驗收**: 所有頻道都能正確發送，失敗能正確處理

---

## 三、Cloudflare Analytics 設定（6 小時）

### 3.1 Metrics Collector（2 小時）

**新增檔案**: [/apps/queue-worker/src/utils/metrics.ts](apps/queue-worker/src/utils/metrics.ts)

```typescript
export class MetricsCollector {
  constructor(private analytics: AnalyticsEngineDataset) {}

  recordQueueProcessing(data: {
    conversationId: string;
    stage: "transcription" | "analysis" | "notification" | "complete";
    durationMs: number;
    success: boolean;
    errorType?: string;
  }) {
    this.analytics.writeDataPoint({
      blobs: [data.conversationId, data.stage, data.success ? "success" : "failure"],
      doubles: [data.durationMs],
      indexes: [`queue:${data.stage}`, data.success ? "success" : "failure"],
    });
  }

  recordAlertEvaluation(data: { /* ... */ }) { /* ... */ }
  recordFollowUpExecution(data: { /* ... */ }) { /* ... */ }
  recordExternalServiceCall(data: { /* ... */ }) { /* ... */ }
}
```

**驗收**: TypeScript 編譯通過

### 3.2 整合到 Queue Worker（2 小時）

**修改檔案**: [/apps/queue-worker/wrangler.toml](apps/queue-worker/wrangler.toml)

```toml
[[analytics_engine_datasets]]
binding = "ANALYTICS"
```

**修改檔案**: [/apps/queue-worker/src/index.ts](apps/queue-worker/src/index.ts)

```typescript
export default {
  async queue(batch, env, ctx) {
    const metrics = new MetricsCollector(env.ANALYTICS);

    for (const message of batch.messages) {
      const startTime = Date.now();

      try {
        // 轉錄階段
        const transcriptionTime = Date.now() - startTime;
        metrics.recordQueueProcessing({
          conversationId,
          stage: "transcription",
          durationMs: transcriptionTime,
          success: true,
        });

        // 分析階段
        // ...

        // 完成
        metrics.recordQueueProcessing({
          conversationId,
          stage: "complete",
          durationMs: Date.now() - startTime,
          success: true,
        });
      } catch (error) {
        metrics.recordQueueProcessing({
          conversationId,
          stage: currentStage,
          durationMs: Date.now() - startTime,
          success: false,
          errorType: error.constructor.name,
        });
      }
    }
  },
};
```

**驗收**: 部署後能在 Dashboard 看到資料點

### 3.3 Alert Rules 設定（1 小時）

**在 Cloudflare Dashboard 設定**:

1. 前往 Cloudflare Dashboard > Notifications > Add
2. 建立 4 個 Alert Rules:

| Alert Name | 條件 | 通知 |
|-----------|------|------|
| 高錯誤率 | 5xx 錯誤率 > 5%（5 分鐘） | Email + Slack |
| Queue 處理過長 | p95 處理時間 > 180 秒 | Slack |
| Scheduled Job 失敗 | scheduled handler 失敗 | Email + Slack |
| 外部服務延遲 | Groq/Gemini p95 > 30 秒 | Slack |

3. 設定 Slack Webhook:
   - 在 Slack 建立 Incoming Webhook
   - 在 Cloudflare Alert 中輸入 Webhook URL

**驗收**: 觸發條件能正確發送通知

### 3.4 設定文檔（1 小時）

**新增檔案**: [/.doc/20260121_Cloudflare_Analytics設定指南.md](.doc/20260121_Cloudflare_Analytics設定指南.md)

**內容包含**:
1. Workers Observability 啟用
2. Analytics Engine 設定
3. 常用 SQL 查詢範例
4. Alert Rules 設定步驟
5. 監控最佳實踐

**驗收**: 新團隊成員能根據文檔獨立設定

---

## 四、整合測試（4 小時）

### 4.1 端到端測試（2 小時）

**Alert 系統測試**:
```bash
# 1. 建立測試商機
# - 高分商機（MEDDIC 70+）
# - 低分商機（< 40）
# - 停滯商機（14 天未聯絡）

# 2. 手動觸發 Scheduled Job
curl -X POST https://your-worker.workers.dev/__scheduled

# 3. 驗證
# - 檢查 alerts 表
# - 檢查 Slack 通知
# - 檢查 Web UI
```

**Follow-up 測試**:
```bash
# 1. 建立測試跟進（scheduledAt: 1 分鐘後）
# 2. 等待執行
# 3. 驗證 Slack 訊息和狀態更新
```

**Analytics 測試**:
```bash
# 1. 執行正常流程
# 2. 前往 Dashboard 執行 SQL 查詢
# 3. 觸發 Alert Rule
# 4. 驗證通知
```

### 4.2 監控驗證和參數調整（2 小時）

**監控項目**:
- Queue 處理時間分布（p50, p95, p99）
- Alert 觸發率
- Follow-up 發送成功率
- 外部服務延遲

**調整項目**:
- Alert 規則參數（根據實際觸發情況）
- Cron 頻率（如需要）
- Slack 通知格式（根據反饋）

---

## 五、關鍵檔案清單

### 修改檔案
- [/packages/db/src/schema/alert.ts](packages/db/src/schema/alert.ts) - 新增 AlertType
- [/packages/services/src/alerts/types.ts](packages/services/src/alerts/types.ts) - 更新 EvaluationContext
- [/packages/services/src/alerts/rules.ts](packages/services/src/alerts/rules.ts) - 調整規則並新增 2 個
- [/packages/services/src/alerts/evaluator.ts](packages/services/src/alerts/evaluator.ts) - 更新 context builder
- [/apps/queue-worker/wrangler.toml](apps/queue-worker/wrangler.toml) - 新增 cron 和 analytics binding
- [/apps/queue-worker/src/index.ts](apps/queue-worker/src/index.ts) - 新增 scheduled handler

### 新增檔案
- [/apps/queue-worker/src/scheduled/alert-evaluator.ts](apps/queue-worker/src/scheduled/alert-evaluator.ts) - Alert 評估核心邏輯
- [/apps/queue-worker/src/scheduled/follow-up-executor.ts](apps/queue-worker/src/scheduled/follow-up-executor.ts) - Follow-up 執行核心邏輯
- [/apps/queue-worker/src/utils/metrics.ts](apps/queue-worker/src/utils/metrics.ts) - Metrics Collector
- [/.doc/20260121_Cloudflare_Analytics設定指南.md](.doc/20260121_Cloudflare_Analytics設定指南.md) - 監控設定文檔

---

## 六、驗收標準總覽

### Alert 系統
- ✅ 5 個規則都能正確觸發
- ✅ Cron Job 每 6 小時自動執行
- ✅ Slack 通知正常發送
- ✅ 去重邏輯正常（24 小時內不重複）
- ✅ Web UI 顯示所有警示類型

### 跟進自動化
- ✅ Cron Job 每 30 分鐘自動執行
- ✅ Slack DM 和 Channel 都能正常發送
- ✅ 狀態正確更新（pending → sent/failed）
- ✅ 錯誤能正確記錄
- ✅ Talk Track 和商機連結正確顯示

### Cloudflare Analytics
- ✅ Dashboard 顯示所有自訂指標
- ✅ 4 個 Alert Rules 能正常觸發通知
- ✅ SQL 查詢返回正確資料
- ✅ 設定文檔完整且可用

---

## 七、風險與注意事項

### 技術風險
1. **Cron 頻率成本** - 監控 Cloudflare 用量，必要時調整
2. **Slack 通知疲勞** - 實作去重邏輯，限制頻率
3. **Alert 規則不符需求** - 務必完成業務訪談

### 向後相容性
- 新增 AlertType 不影響現有警示
- EvaluationContext 新欄位使用可選類型
- 現有 API 保持不變

### 效能影響
- Alert Evaluator 每 6 小時執行，資料庫負擔小
- Follow-up Executor 查詢有索引（scheduledAt, status）
- Analytics 寫入是非阻塞的

---

## 八、實作順序

### Week 1, Day 1-2（8 小時）
1. Cloudflare Analytics 設定（6 小時）
2. Alert 業務需求收集 + Schema 更新（2 小時）

### Week 1, Day 3-4（13 小時）
3. Alert 規則更新 + Evaluator 實作（7 小時）
4. Alert 整合和測試（6 小時）

### Week 1, Day 5（9 小時）
5. Follow-up Executor 實作 + 整合（9 小時）

### Week 2, Day 1（4 小時）
6. 整合測試和調整（4 小時）

**總開發時間**: 約 1.5 週（35 小時）
