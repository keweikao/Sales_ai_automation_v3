# V2 vs V3 éŸ³æª”è™•ç†æ¶æ§‹å·®ç•°åˆ†æèˆ‡ä¿®å¾©æ–¹æ¡ˆ

## èƒŒæ™¯æ‘˜è¦

### æ ¸å¿ƒå•é¡Œ

V3 ç•¶å‰æ¶æ§‹é‡åˆ°çš„ä¸»è¦å•é¡Œ:
1. **96MB éŸ³æª”è™•ç†è¶…æ™‚** - åŒæ­¥è½‰éŒ„é˜»å¡ä¸»è«‹æ±‚ 5-10 åˆ†é˜,è¶…é Cloudflare Workers é™åˆ¶
2. **NeonDbError** - èƒŒæ™¯ä»»å‹™ (executionCtx.waitUntil) ä¸­è³‡æ–™åº«æ›´æ–°å¤±æ•—
3. **ç¼ºä¹éŒ¯èª¤é€šçŸ¥** - ç”¨æˆ¶çœ‹åˆ°ç„¡ç›¡çš„ "è™•ç†ä¸­...",ç„¡å¤±æ•—æç¤º
4. **é€²åº¦è¿½è¹¤ä¸è¶³** - åªæœ‰ç°¡å–®çš„ 3 å€‹ç‹€æ…‹,ç„¡ç´°ç²’åº¦é€²åº¦

### V2 vs V3 æ¶æ§‹æ ¸å¿ƒå·®ç•°

| ç¶­åº¦ | V2 (GCP / Python) | V3 (Cloudflare / TypeScript) | å½±éŸ¿ |
|------|-------------------|------------------------------|------|
| **è½‰éŒ„åŸ·è¡Œ** | âœ… Cloud Tasks ç•°æ­¥ (30åˆ†é˜è¶…æ™‚) | âŒ åŒæ­¥åŸ·è¡Œ (é˜»å¡ä¸»è«‹æ±‚) | **åš´é‡** |
| **è³‡æ–™åº«** | âœ… Firestore (ç•°æ­¥å‹å–„) | âŒ Neon Postgres (èƒŒæ™¯ä»»å‹™ä¸ç©©å®š) | **åš´é‡** |
| **é€²åº¦è¿½è¹¤** | âœ… ç´°ç²’åº¦ (step/progress/chunks) | âŒ ç°¡å–®ç‹€æ…‹ (3å€‹ç‹€æ…‹) | **ä¸­ç­‰** |
| **éŒ¯èª¤é€šçŸ¥** | âœ… Slack è¨Šæ¯ + DB è¨˜éŒ„ | âŒ åƒ…æ—¥èªŒ,ç„¡ç”¨æˆ¶é€šçŸ¥ | **ä¸­ç­‰** |

### V2 æˆåŠŸçš„é—œéµ

V2 è™•ç†æµç¨‹:
```
Slack ä¸Šå‚³éŸ³æª” â†’ Flask App ç«‹å³ ack (< 3ç§’) 
  â†’ èƒŒæ™¯ç·šç¨‹ä¸Šå‚³åˆ° GCS 
  â†’ Cloud Task Queue (ç¨ç«‹ç’°å¢ƒ,30 åˆ†é˜è¶…æ™‚)
  â†’ è½‰éŒ„ + åˆ†æ + æ›´æ–° Firestore
  â†’ Slack é€šçŸ¥å®Œæˆ
```

**é—œéµå„ªå‹¢:**
- âœ… ç”¨æˆ¶ç«‹å³å¾—åˆ°å›æ‡‰ (< 3 ç§’)
- âœ… è½‰éŒ„åœ¨ç¨ç«‹ç’°å¢ƒåŸ·è¡Œ (30 åˆ†é˜è¶³å¤ è™•ç†ä»»ä½•æª”æ¡ˆ)
- âœ… å¤±æ•—è‡ªå‹•é‡è©¦
- âœ… å®Œæ•´é€²åº¦è¿½è¹¤å’Œ Slack é€šçŸ¥

### V3 çš„å•é¡Œæ¨¡å¼

V3 ç•¶å‰æµç¨‹:
```
Slack ä¸Šå‚³éŸ³æª” â†’ API uploadConversation (åŒæ­¥)
  â†’ ä¸‹è¼‰ (2-3 åˆ†é˜)
  â†’ ä¸Šå‚³ R2 (1-2 åˆ†é˜)
  â†’ Whisper è½‰éŒ„ (2-5 åˆ†é˜) â† é˜»å¡ä¸»è«‹æ±‚!
  â†’ ä¿å­˜ DB
  â†’ executionCtx.waitUntil() èƒŒæ™¯åˆ†æ â† NeonDbError!
```

**æ ¸å¿ƒå•é¡Œ:**
- âŒ ä¸»è«‹æ±‚è¢«è½‰éŒ„é˜»å¡ (96MB â†’ 5-10 åˆ†é˜),è¶…é Workers é™åˆ¶
- âŒ èƒŒæ™¯ä»»å‹™è³‡æ–™åº«é€£æ¥ä¸ç©©å®š (Neon HTTP-based,é€£æ¥æ± åœ¨ response å¾Œé—œé–‰)
- âŒ ç„¡éŒ¯èª¤é€šçŸ¥æ©Ÿåˆ¶

### è§£æ±ºæ–¹æ¡ˆ: Cloudflare Queue æ¶æ§‹

æ¡ç”¨ Cloudflare Queue å¯ä»¥è¤‡è£½ V2 çš„æˆåŠŸæ¨¡å¼:

```
Slack ä¸Šå‚³ â†’ API ä¸Šå‚³ R2 + å»ºç«‹ DB (pending) + æ¨é€ Queue â†’ ç«‹å³è¿”å› (< 3ç§’)
                                    â†“
                          Queue Consumer Worker (ç¨ç«‹ç’°å¢ƒ)
                                    â†“
                    ä¸‹è¼‰ â†’ è½‰éŒ„ â†’ åˆ†æ â†’ æ›´æ–° DB â†’ Slack é€šçŸ¥
```

**å„ªå‹¢:**
- âœ… ç„¡ CPU æ™‚é–“é™åˆ¶ (Queue Consumer åªæœ‰ wall time é™åˆ¶)
- âœ… ç¨ç«‹è«‹æ±‚ç’°å¢ƒ,è³‡æ–™åº«é€£æ¥ç©©å®š
- âœ… å…§å»ºé‡è©¦æ©Ÿåˆ¶ (æœ€å¤š 3 æ¬¡)
- âœ… Dead Letter Queue æ”¶é›†å¤±æ•—ä»»å‹™
- âœ… ä¿æŒåœ¨ Cloudflare ç”Ÿæ…‹å…§

---

## åã€å®Œæ•´å„ªåŒ–è¦åŠƒ (ä¸å« D1 é·ç§»)

### 10.1 è¦åŠƒç¸½è¦½

**ç›®æ¨™:** åœ¨ 2-3 é€±å…§å®Œæˆæ ¸å¿ƒæ¶æ§‹å„ªåŒ–,è§£æ±ºæ‰€æœ‰ä»Šå¤©é‡åˆ°çš„å•é¡Œ

**ç¯„åœ:**
- âœ… Cloudflare Queue æ¶æ§‹
- âœ… çµ±ä¸€éŒ¯èª¤è™•ç†
- âœ… Slack é€šçŸ¥ç³»çµ±
- âœ… Better-T Stack æ¨¡çµ„åŒ–çµæ§‹
- âœ… Turborepo æ§‹å»ºå„ªåŒ–
- âš ï¸ tRPC é·ç§» (å¯é¸,è©•ä¼°å¾Œæ±ºå®š)
- âŒ D1 é·ç§» (æš«ä¸è€ƒæ…®)

**é æœŸæˆæœ:**
- 100% è§£æ±ºå¤§æª”æ¡ˆè¶…æ™‚å•é¡Œ
- 100% è§£æ±ºè³‡æ–™åº«ç©©å®šæ€§å•é¡Œ
- +80% æ”¹å–„éŒ¯èª¤è™•ç†
- +60% æ”¹å–„ Debug æ•ˆç‡
- +40% æ”¹å–„æ§‹å»ºé€Ÿåº¦

### 10.2 ä¸‰é€±å¯¦æ–½æ™‚é–“è¡¨

```
Week 1: æ ¸å¿ƒæ¶æ§‹ä¿®å¾© (5 å¤©)
â”œâ”€ Day 1-2: Cloudflare Queue + Queue Worker
â”œâ”€ Day 3: çµ±ä¸€éŒ¯èª¤è™•ç†ç³»çµ±
â”œâ”€ Day 4: Slack é€šçŸ¥æœå‹™
â””â”€ Day 5: æ•´åˆæ¸¬è©¦ + Bug ä¿®å¾©

Week 2: Better-T Stack é‡æ§‹ (5 å¤©)
â”œâ”€ Day 1: Turborepo é…ç½®
â”œâ”€ Day 2-3: Packages é‡çµ„ (shared/types/schemas)
â”œâ”€ Day 4: tRPC è©•ä¼° + POC
â””â”€ Day 5: æ±ºç­– + æ–‡æª”

Week 3: æ¸¬è©¦èˆ‡ä¸Šç·š (5 å¤©)
â”œâ”€ Day 1-2: å®Œæ•´æ¸¬è©¦ (å–®å…ƒ + æ•´åˆ + E2E)
â”œâ”€ Day 3: æ€§èƒ½æ¸¬è©¦ + å£“åŠ›æ¸¬è©¦
â”œâ”€ Day 4: éƒ¨ç½²åˆ°ç”Ÿç”¢ç’°å¢ƒ
â””â”€ Day 5: ç›£æ§ + èª¿å„ª
```

### 10.3 Week 1: æ ¸å¿ƒæ¶æ§‹ä¿®å¾©

#### Day 1-2: Cloudflare Queue + Queue Worker

**ä»»å‹™æ¸…å–®:**

**Day 1 ä¸Šåˆ: Queue é…ç½®**
- [ ] æ›´æ–° `apps/server/wrangler.toml` æ·»åŠ  Queue
- [ ] å‰µå»º Queue Consumer çš„ wrangler.toml
- [ ] æ¸¬è©¦ Queue é€£æ¥

**Day 1 ä¸‹åˆ: Queue Worker éª¨æ¶**
- [ ] å‰µå»º `apps/queue-worker/` ç›®éŒ„çµæ§‹
- [ ] å¯¦ç¾åŸºæœ¬çš„ Queue Consumer handler
- [ ] æ¸¬è©¦è¨Šæ¯æ¥æ”¶å’Œ ack

**Day 2 ä¸Šåˆ: é·ç§»è½‰éŒ„é‚è¼¯**
- [ ] å¾ `conversation.ts` æå–è½‰éŒ„é‚è¼¯
- [ ] åœ¨ Queue Worker ä¸­å¯¦ç¾ `processTranscription`
- [ ] æ¸¬è©¦å°æª”æ¡ˆ (< 10MB) è™•ç†

**Day 2 ä¸‹åˆ: æ•´åˆ MEDDIC åˆ†æ**
- [ ] åœ¨ Queue Worker ä¸­æ•´åˆ Orchestrator
- [ ] å¯¦ç¾å®Œæ•´è™•ç†æµç¨‹
- [ ] æ¸¬è©¦å¤§æª”æ¡ˆ (96MB) è™•ç†

**é—œéµæ–‡ä»¶:**

```typescript
// apps/queue-worker/wrangler.toml
name = "sales-ai-queue-worker"
main = "src/index.ts"
compatibility_date = "2024-01-01"

[[queues.consumers]]
queue = "transcription-queue"
max_batch_size = 1
max_retries = 3
max_wait_time_ms = 60000
dead_letter_queue = "transcription-dlq"

[env.production]
vars = { ENVIRONMENT = "production" }

[env.dev]
vars = { ENVIRONMENT = "development" }
```

```typescript
// apps/queue-worker/src/index.ts
import type { MessageBatch } from '@cloudflare/workers-types';
import { drizzle } from 'drizzle-orm/neon-http';
import { neon } from '@neondatabase/serverless';
import { createGroqWhisperService, createGeminiClient, createOrchestrator } from '@Sales_ai_automation_v3/services';

export interface Env {
  DATABASE_URL: string;
  GROQ_API_KEY: string;
  GEMINI_API_KEY: string;
  CLOUDFLARE_R2_ACCESS_KEY: string;
  CLOUDFLARE_R2_SECRET_KEY: string;
  CLOUDFLARE_R2_ENDPOINT: string;
  CLOUDFLARE_R2_BUCKET: string;
  SLACK_BOT_TOKEN: string;
}

export interface TranscriptionMessage {
  conversationId: string;
  opportunityId: string;
  audioUrl: string;
  slackUserId?: string;
  slackChannelId?: string;
  metadata: {
    fileName: string;
    fileSize: number;
    format: string;
  };
}

export default {
  async queue(
    batch: MessageBatch<TranscriptionMessage>,
    env: Env,
    ctx: ExecutionContext
  ): Promise<void> {
    const sql = neon(env.DATABASE_URL);
    const db = drizzle(sql);

    for (const message of batch.messages) {
      const startTime = Date.now();
      const { conversationId, audioUrl, opportunityId, slackUserId, metadata } = message.body;

      try {
        console.log(`[Queue] Processing ${conversationId} - ${metadata.fileName}`);

        // 1. ä¸‹è¼‰éŸ³æª”å¾ R2
        const audioBuffer = await downloadFromR2(audioUrl, env);
        console.log(`[Queue] Downloaded ${audioBuffer.length} bytes`);

        // 2. Whisper è½‰éŒ„
        const whisper = createGroqWhisperService(env.GROQ_API_KEY);
        const transcriptResult = await whisper.transcribe(audioBuffer, {
          language: 'zh',
          chunkIfNeeded: true,
        });
        console.log(`[Queue] Transcription completed: ${transcriptResult.fullText.length} chars`);

        // 3. æ›´æ–°è³‡æ–™åº« (transcribed)
        await db.update(conversations)
          .set({
            status: 'transcribed',
            transcript: {
              fullText: transcriptResult.fullText,
              language: transcriptResult.language,
              segments: transcriptResult.segments,
            },
            updatedAt: new Date(),
          })
          .where(eq(conversations.id, conversationId));

        // 4. MEDDIC åˆ†æ
        const gemini = createGeminiClient(env.GEMINI_API_KEY);
        const orchestrator = createOrchestrator(gemini);
        const analysisResult = await orchestrator.analyze(
          transcriptResult.segments,
          {
            leadId: opportunityId,
            conversationId: conversationId,
          }
        );
        console.log(`[Queue] Analysis completed: ${analysisResult.overallScore}`);

        // 5. ä¿å­˜åˆ†æçµæœ
        await db.update(conversations)
          .set({
            status: 'completed',
            meddicAnalysis: {
              overallScore: analysisResult.overallScore,
              status: analysisResult.qualificationStatus,
              dimensions: analysisResult.dimensions,
            },
            analyzedAt: new Date(),
          })
          .where(eq(conversations.id, conversationId));

        // 6. ç™¼é€ Slack é€šçŸ¥
        if (slackUserId && env.SLACK_BOT_TOKEN) {
          await notifySlackCompletion(slackUserId, conversationId, analysisResult, env);
        }

        // 7. Ack æ¶ˆæ¯
        message.ack();

        const duration = Date.now() - startTime;
        console.log(`[Queue] âœ… Completed ${conversationId} in ${duration}ms`);

      } catch (error) {
        console.error(`[Queue] âŒ Failed ${conversationId}:`, error);

        // æ›´æ–°ç‚ºå¤±æ•—ç‹€æ…‹
        await db.update(conversations)
          .set({
            status: 'failed',
            updatedAt: new Date(),
          })
          .where(eq(conversations.id, conversationId));

        // é€šçŸ¥ Slack å¤±æ•—
        if (slackUserId && env.SLACK_BOT_TOKEN) {
          await notifySlackError(slackUserId, error, env);
        }

        // Retry (ç”± Queue è‡ªå‹•è™•ç†)
        message.retry();
      }
    }
  },
};

async function downloadFromR2(url: string, env: Env): Promise<Buffer> {
  // R2 ä¸‹è¼‰å¯¦ç¾
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to download from R2: ${response.statusText}`);
  }
  const arrayBuffer = await response.arrayBuffer();
  return Buffer.from(arrayBuffer);
}

async function notifySlackCompletion(
  userId: string,
  conversationId: string,
  analysis: any,
  env: Env
): Promise<void> {
  // Slack é€šçŸ¥å¯¦ç¾ (Day 4 å®Œæˆ)
  console.log(`[Queue] Sending completion notification to ${userId}`);
}

async function notifySlackError(
  userId: string,
  error: Error,
  env: Env
): Promise<void> {
  // Slack éŒ¯èª¤é€šçŸ¥å¯¦ç¾ (Day 4 å®Œæˆ)
  console.log(`[Queue] Sending error notification to ${userId}`);
}
```

```typescript
// apps/server/wrangler.toml (æ›´æ–°)
[[queues.producers]]
queue = "transcription-queue"
binding = "TRANSCRIPTION_QUEUE"
```

```typescript
// packages/api/src/routers/conversation.ts (ä¿®æ”¹ uploadConversation)
export const uploadConversation = protectedProcedure
  .input(uploadConversationSchema)
  .handler(async ({ input, context }) => {
    // ... å‰é¢çš„é©—è­‰å’Œä¸Šå‚³é‚è¼¯ä¿æŒä¸è®Š ...

    // Step 5: å»ºç«‹è³‡æ–™åº«è¨˜éŒ„ (status: "pending")
    const conversationId = randomUUID();
    await db.insert(conversations).values({
      id: conversationId,
      opportunityId,
      caseNumber,
      title: input.title,
      type: input.type,
      status: 'pending',  // â† æ”¹ç‚º pending
      audioUrl,
      transcript: null,   // â† ç¨å¾Œç”± Queue Worker å¡«å……
      duration: 0,
      conversationDate: new Date(input.metadata.conversationDate),
      createdBy: slackUser?.username || 'unknown',
    });

    // Step 6: æ¨é€åˆ° Queue
    const envRecord = env as Record<string, unknown>;
    await (envRecord.TRANSCRIPTION_QUEUE as any).send({
      conversationId,
      opportunityId,
      audioUrl,
      slackUserId: slackUser?.id,
      slackChannelId: slackUser?.channelId,
      metadata: {
        fileName: input.title,
        fileSize: audioBuffer.length,
        format: input.metadata.format || 'unknown',
      },
    });

    // Step 7: ç«‹å³è¿”å› (ä¸ç­‰å¾…è½‰éŒ„)
    return {
      conversationId,
      caseNumber,
      status: 'pending',
      message: 'å·²æ¥æ”¶éŸ³æª”,æ­£åœ¨è™•ç†ä¸­...',
    };

    // âŒ ç§»é™¤æ‰€æœ‰ executionCtx.waitUntil() çš„ç¨‹å¼ç¢¼
  });
```

#### Day 3: çµ±ä¸€éŒ¯èª¤è™•ç†ç³»çµ±

**ä»»å‹™æ¸…å–®:**
- [ ] å‰µå»º `packages/shared/` çµæ§‹
- [ ] å¯¦ç¾ `AppError` é¡åˆ¥å’ŒéŒ¯èª¤å®šç¾©
- [ ] æ›´æ–°æ‰€æœ‰ throw èªå¥ä½¿ç”¨çµ±ä¸€éŒ¯èª¤
- [ ] æ·»åŠ éŒ¯èª¤ä¸­é–“ä»¶

**é—œéµæ–‡ä»¶:**

```typescript
// packages/shared/src/errors/index.ts
export class AppError extends Error {
  constructor(
    public readonly code: string,
    public readonly statusCode: number,
    message: string,
    public readonly userMessage?: string,
    public readonly details?: Record<string, any>
  ) {
    super(message);
    this.name = 'AppError';
    Error.captureStackTrace(this, this.constructor);
  }

  toJSON() {
    return {
      code: this.code,
      statusCode: this.statusCode,
      message: this.message,
      userMessage: this.userMessage,
      details: this.details,
    };
  }
}

export const errors = {
  // æª”æ¡ˆç›¸é—œ
  AUDIO_TOO_LARGE: (sizeInMB: number) =>
    new AppError(
      'AUDIO_TOO_LARGE',
      413,
      `Audio file size ${sizeInMB}MB exceeds limit`,
      `éŸ³æª”éå¤§ (${sizeInMB}MB),è«‹ä¸Šå‚³å°æ–¼ 200MB çš„æª”æ¡ˆ`,
      { sizeInMB }
    ),

  INVALID_AUDIO_FORMAT: (format: string) =>
    new AppError(
      'INVALID_AUDIO_FORMAT',
      400,
      `Unsupported audio format: ${format}`,
      `ä¸æ”¯æ´çš„éŸ³æª”æ ¼å¼: ${format}`,
      { format }
    ),

  FILE_DOWNLOAD_FAILED: (url: string) =>
    new AppError(
      'FILE_DOWNLOAD_FAILED',
      500,
      `Failed to download file from ${url}`,
      'éŸ³æª”ä¸‹è¼‰å¤±æ•—,è«‹ç¨å¾Œå†è©¦',
      { url }
    ),

  // è½‰éŒ„ç›¸é—œ
  TRANSCRIPTION_FAILED: (reason: string) =>
    new AppError(
      'TRANSCRIPTION_FAILED',
      500,
      `Transcription failed: ${reason}`,
      'è½‰éŒ„è™•ç†å¤±æ•—,è«‹ç¨å¾Œå†è©¦',
      { reason }
    ),

  TRANSCRIPTION_TIMEOUT: () =>
    new AppError(
      'TRANSCRIPTION_TIMEOUT',
      504,
      'Transcription timeout',
      'è½‰éŒ„è™•ç†é€¾æ™‚,è«‹ç¨å¾Œå†è©¦'
    ),

  // API ç›¸é—œ
  GROQ_API_ERROR: (message: string) =>
    new AppError(
      'GROQ_API_ERROR',
      503,
      `Groq API error: ${message}`,
      'Groq æœå‹™æš«æ™‚ä¸å¯ç”¨,è«‹ç¨å¾Œå†è©¦',
      { message }
    ),

  GEMINI_API_ERROR: (message: string) =>
    new AppError(
      'GEMINI_API_ERROR',
      503,
      `Gemini API error: ${message}`,
      'Gemini æœå‹™æš«æ™‚ä¸å¯ç”¨,è«‹ç¨å¾Œå†è©¦',
      { message }
    ),

  // è³‡æ–™åº«ç›¸é—œ
  DATABASE_ERROR: (operation: string, error: Error) =>
    new AppError(
      'DATABASE_ERROR',
      500,
      `Database ${operation} failed: ${error.message}`,
      'è³‡æ–™åº«æ“ä½œå¤±æ•—,è«‹ç¨å¾Œå†è©¦',
      { operation, originalError: error.message }
    ),

  RECORD_NOT_FOUND: (entity: string, id: string) =>
    new AppError(
      'RECORD_NOT_FOUND',
      404,
      `${entity} not found: ${id}`,
      `æ‰¾ä¸åˆ°æŒ‡å®šçš„${entity}`,
      { entity, id }
    ),

  // æ¥­å‹™é‚è¼¯ç›¸é—œ
  OPPORTUNITY_NOT_FOUND: (id: string) =>
    new AppError(
      'OPPORTUNITY_NOT_FOUND',
      404,
      `Opportunity not found: ${id}`,
      'æ‰¾ä¸åˆ°æŒ‡å®šçš„å•†æ©Ÿ',
      { opportunityId: id }
    ),

  UNAUTHORIZED: () =>
    new AppError(
      'UNAUTHORIZED',
      401,
      'Unauthorized access',
      'æœªæˆæ¬Šçš„è¨ªå•'
    ),
} as const;

// éŒ¯èª¤è™•ç†å·¥å…·å‡½æ•¸
export function isAppError(error: unknown): error is AppError {
  return error instanceof AppError;
}

export function formatErrorForUser(error: unknown): string {
  if (isAppError(error)) {
    return error.userMessage || error.message;
  }

  if (error instanceof Error) {
    return 'ç™¼ç”Ÿæœªé æœŸçš„éŒ¯èª¤,è«‹è¯ç¹«æŠ€è¡“æ”¯æ´';
  }

  return 'ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤';
}

export function formatErrorForLog(error: unknown): Record<string, any> {
  if (isAppError(error)) {
    return error.toJSON();
  }

  if (error instanceof Error) {
    return {
      name: error.name,
      message: error.message,
      stack: error.stack,
    };
  }

  return {
    error: String(error),
  };
}
```

```typescript
// packages/shared/src/index.ts
export * from './errors';
export * from './types';  // Day 2-3 Week 2 æ·»åŠ 
export * from './schemas';  // Day 2-3 Week 2 æ·»åŠ 
```

**ä½¿ç”¨ç¯„ä¾‹:**

```typescript
// packages/services/src/transcription/groq-whisper.ts (æ›´æ–°)
import { errors } from '@Sales_ai_automation_v3/shared';

export class GroqWhisperService implements TranscriptionService {
  async transcribe(audioBuffer: Buffer, options?: TranscriptionOptions): Promise<TranscriptResult> {
    try {
      // ... è½‰éŒ„é‚è¼¯ ...
    } catch (error) {
      if (error instanceof Error && error.message.includes('timeout')) {
        throw errors.TRANSCRIPTION_TIMEOUT();
      }

      if (error instanceof Error && error.message.includes('API')) {
        throw errors.GROQ_API_ERROR(error.message);
      }

      throw errors.TRANSCRIPTION_FAILED(error instanceof Error ? error.message : String(error));
    }
  }
}
```

```typescript
// apps/queue-worker/src/index.ts (æ›´æ–°éŒ¯èª¤è™•ç†)
import { errors, formatErrorForUser, formatErrorForLog } from '@Sales_ai_automation_v3/shared';

export default {
  async queue(batch, env, ctx) {
    for (const message of batch.messages) {
      try {
        // ... è™•ç†é‚è¼¯ ...
      } catch (error) {
        console.error(`[Queue] âŒ Failed ${conversationId}:`, formatErrorForLog(error));

        await db.update(conversations).set({
          status: 'failed',
          errorMessage: formatErrorForUser(error),  // â† ä¿å­˜ç”¨æˆ¶å‹å–„çš„éŒ¯èª¤è¨Šæ¯
        });

        if (slackUserId) {
          await notifySlackError(slackUserId, formatErrorForUser(error), env);
        }

        message.retry();
      }
    }
  }
};
```

#### Day 4: Slack é€šçŸ¥æœå‹™

**ä»»å‹™æ¸…å–®:**
- [ ] å‰µå»º `packages/services/src/notifications/` ç›®éŒ„
- [ ] å¯¦ç¾ Slack é€šçŸ¥æœå‹™
- [ ] æ•´åˆåˆ° Queue Worker
- [ ] æ¸¬è©¦é€šçŸ¥ç™¼é€

**é—œéµæ–‡ä»¶:**

```typescript
// packages/services/src/notifications/slack.ts
import { WebClient } from '@slack/web-api';

export interface SlackNotificationService {
  notifyTranscriptionComplete(params: {
    userId: string;
    conversationId: string;
    caseNumber: string;
    analysisResult: any;
  }): Promise<void>;

  notifyTranscriptionFailed(params: {
    userId: string;
    fileName: string;
    errorMessage: string;
  }): Promise<void>;

  notifyProcessingStarted(params: {
    userId: string;
    fileName: string;
    caseNumber: string;
  }): Promise<void>;
}

export function createSlackNotificationService(token: string): SlackNotificationService {
  const client = new WebClient(token);

  return {
    async notifyTranscriptionComplete({ userId, conversationId, caseNumber, analysisResult }) {
      const blocks = [
        {
          type: 'header',
          text: {
            type: 'plain_text',
            text: 'âœ… éŸ³æª”è™•ç†å®Œæˆ',
            emoji: true,
          },
        },
        {
          type: 'section',
          fields: [
            {
              type: 'mrkdwn',
              text: `*æ¡ˆä»¶ç·¨è™Ÿ:*\n${caseNumber}`,
            },
            {
              type: 'mrkdwn',
              text: `*MEDDIC åˆ†æ•¸:*\n${analysisResult.overallScore}/100`,
            },
            {
              type: 'mrkdwn',
              text: `*ç‹€æ…‹:*\n${analysisResult.qualificationStatus}`,
            },
          ],
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: '*ç¶­åº¦è©•åˆ†:*',
          },
        },
      ];

      // æ·»åŠ å„ç¶­åº¦åˆ†æ•¸
      for (const [key, dimension] of Object.entries(analysisResult.dimensions)) {
        blocks.push({
          type: 'section',
          fields: [
            {
              type: 'mrkdwn',
              text: `*${dimension.name}:*`,
            },
            {
              type: 'mrkdwn',
              text: `${dimension.score}/100`,
            },
          ],
        });
      }

      // æ·»åŠ æ“ä½œæŒ‰éˆ•
      blocks.push({
        type: 'actions',
        elements: [
          {
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'ğŸ“ æŸ¥çœ‹å®Œæ•´è½‰éŒ„',
              emoji: true,
            },
            action_id: 'view_full_transcript',
            value: conversationId,
          },
          {
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'ğŸ“Š æŸ¥çœ‹è©³ç´°åˆ†æ',
              emoji: true,
            },
            action_id: 'view_analysis',
            value: conversationId,
            style: 'primary',
          },
        ],
      });

      await client.chat.postMessage({
        channel: userId,
        blocks,
        text: `âœ… éŸ³æª”è™•ç†å®Œæˆ - æ¡ˆä»¶ç·¨è™Ÿ: ${caseNumber}`,
      });
    },

    async notifyTranscriptionFailed({ userId, fileName, errorMessage }) {
      await client.chat.postMessage({
        channel: userId,
        blocks: [
          {
            type: 'header',
            text: {
              type: 'plain_text',
              text: 'âŒ éŸ³æª”è™•ç†å¤±æ•—',
              emoji: true,
            },
          },
          {
            type: 'section',
            fields: [
              {
                type: 'mrkdwn',
                text: `*æª”æ¡ˆåç¨±:*\n${fileName}`,
              },
              {
                type: 'mrkdwn',
                text: `*éŒ¯èª¤è¨Šæ¯:*\n${errorMessage}`,
              },
            ],
          },
          {
            type: 'context',
            elements: [
              {
                type: 'mrkdwn',
                text: 'ğŸ’¡ è«‹æª¢æŸ¥éŸ³æª”æ ¼å¼å’Œå¤§å°,æˆ–ç¨å¾Œå†è©¦',
              },
            ],
          },
        ],
        text: `âŒ éŸ³æª”è™•ç†å¤±æ•—: ${fileName}`,
      });
    },

    async notifyProcessingStarted({ userId, fileName, caseNumber }) {
      await client.chat.postMessage({
        channel: userId,
        blocks: [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `:hourglass_flowing_sand: å·²æ¥æ”¶éŸ³æª”ã€Œ${fileName}ã€\n*æ¡ˆä»¶ç·¨è™Ÿ:* ${caseNumber}\næ­£åœ¨è™•ç†è½‰éŒ„å’Œ MEDDIC åˆ†æ,å®Œæˆå¾Œæœƒé€šçŸ¥æ‚¨...`,
            },
          },
        ],
        text: `å·²æ¥æ”¶éŸ³æª”ã€Œ${fileName}ã€`,
      });
    },
  };
}
```

```typescript
// apps/queue-worker/src/index.ts (æ›´æ–°é€šçŸ¥å¯¦ç¾)
import { createSlackNotificationService } from '@Sales_ai_automation_v3/services/notifications/slack';

async function notifySlackCompletion(
  userId: string,
  conversationId: string,
  caseNumber: string,
  analysis: any,
  env: Env
): Promise<void> {
  const slack = createSlackNotificationService(env.SLACK_BOT_TOKEN);
  await slack.notifyTranscriptionComplete({
    userId,
    conversationId,
    caseNumber,
    analysisResult: analysis,
  });
}

async function notifySlackError(
  userId: string,
  fileName: string,
  error: string,
  env: Env
): Promise<void> {
  const slack = createSlackNotificationService(env.SLACK_BOT_TOKEN);
  await slack.notifyTranscriptionFailed({
    userId,
    fileName,
    errorMessage: error,
  });
}
```

```typescript
// apps/slack-bot/src/events/file.ts (æ›´æ–°ç«‹å³é€šçŸ¥)
import { createSlackNotificationService } from '@Sales_ai_automation_v3/services/notifications/slack';

async function processAudioWithMetadata(...) {
  // ... é©—è­‰å’Œä¸Šå‚³é‚è¼¯ ...

  // å‘¼å« API
  const uploadResult = await apiClient.rpc.conversations.upload({
    json: { ... }
  });

  // ç«‹å³é€šçŸ¥ç”¨æˆ¶
  const slack = createSlackNotificationService(env.SLACK_BOT_TOKEN);
  await slack.notifyProcessingStarted({
    userId: slackUser.id,
    fileName: file.name,
    caseNumber: uploadResult.json.caseNumber,
  });

  // âŒ ä¸å†ç­‰å¾…è½‰éŒ„å®Œæˆ
  // Queue Worker æœƒåœ¨å®Œæˆå¾Œè‡ªå‹•é€šçŸ¥
}
```

#### Day 5: æ•´åˆæ¸¬è©¦ + Bug ä¿®å¾©

**æ¸¬è©¦æ¸…å–®:**
- [ ] å–®å…ƒæ¸¬è©¦: Queue Worker å„å‡½æ•¸
- [ ] æ•´åˆæ¸¬è©¦: å®Œæ•´æµç¨‹ (å°æª”æ¡ˆ)
- [ ] æ•´åˆæ¸¬è©¦: å®Œæ•´æµç¨‹ (å¤§æª”æ¡ˆ 96MB)
- [ ] éŒ¯èª¤æ¸¬è©¦: å„ç¨®å¤±æ•—å ´æ™¯
- [ ] é€šçŸ¥æ¸¬è©¦: Slack è¨Šæ¯æ ¼å¼
- [ ] æ€§èƒ½æ¸¬è©¦: è™•ç†æ™‚é–“åˆ†æ

**æ¸¬è©¦è…³æœ¬:**

```bash
# test-queue-integration.sh
#!/bin/bash

echo "ğŸ§ª Testing Queue Integration..."

# 1. å°æª”æ¡ˆæ¸¬è©¦ (5MB)
echo "\nğŸ“ Test 1: Small file (5MB)"
API_TOKEN=$API_TOKEN npx tsx test-upload-api-directly.ts ./test-files/small-5mb.mp3 test-opportunity-id

# 2. ä¸­æª”æ¡ˆæ¸¬è©¦ (20MB)
echo "\nğŸ“ Test 2: Medium file (20MB)"
API_TOKEN=$API_TOKEN npx tsx test-upload-api-directly.ts ./test-files/medium-20mb.mp3 test-opportunity-id

# 3. å¤§æª”æ¡ˆæ¸¬è©¦ (96MB)
echo "\nğŸ“ Test 3: Large file (96MB)"
API_TOKEN=$API_TOKEN npx tsx test-upload-api-directly.ts ./test-files/large-96mb.mp3 test-opportunity-id

# 4. æª¢æŸ¥ Queue ç‹€æ…‹
echo "\nğŸ“Š Checking Queue status..."
npx wrangler queues list

# 5. æª¢æŸ¥è³‡æ–™åº«è¨˜éŒ„
echo "\nğŸ—„ï¸ Checking database records..."
DATABASE_URL=$DATABASE_URL npx tsx check-db-conversations.ts

echo "\nâœ… Integration test completed"
```

### 10.4 Week 2: Better-T Stack é‡æ§‹

#### Day 1: Turborepo é…ç½®

**ä»»å‹™æ¸…å–®:**
- [ ] å®‰è£ Turborepo ä¾è³´
- [ ] å‰µå»º `turbo.json` é…ç½®
- [ ] æ›´æ–° `package.json` scripts
- [ ] æ¸¬è©¦æ§‹å»ºæ€§èƒ½

**é—œéµæ–‡ä»¶:**

```json
// turbo.json
{
  "$schema": "https://turbo.build/schema.json",
  "globalDependencies": ["**/.env.*local"],
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": [".next/**", "!.next/cache/**", "dist/**"]
    },
    "lint": {
      "dependsOn": ["^lint"]
    },
    "dev": {
      "cache": false,
      "persistent": true
    },
    "deploy": {
      "dependsOn": ["build", "lint"],
      "outputs": []
    },
    "test": {
      "dependsOn": ["^build"],
      "outputs": ["coverage/**"]
    }
  }
}
```

```json
// package.json (root)
{
  "name": "sales-ai-automation-v3",
  "private": true,
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "build": "turbo run build",
    "dev": "turbo run dev",
    "lint": "turbo run lint",
    "test": "turbo run test",
    "deploy": "turbo run deploy",
    "clean": "turbo run clean && rm -rf node_modules"
  },
  "devDependencies": {
    "turbo": "^2.0.0"
  }
}
```

#### Day 2-3: Packages é‡çµ„

**ä»»å‹™æ¸…å–®:**
- [ ] å‰µå»º `packages/shared/` å®Œæ•´çµæ§‹
- [ ] æå–å…±äº«é¡å‹åˆ° `shared/types`
- [ ] æå– Zod schemas åˆ° `shared/schemas`
- [ ] æ›´æ–°æ‰€æœ‰ imports
- [ ] æ¸¬è©¦é¡å‹æª¢æŸ¥

**ç›®æ¨™çµæ§‹:**

```
packages/
â”œâ”€ shared/
â”‚  â”œâ”€ package.json
â”‚  â”œâ”€ tsconfig.json
â”‚  â”œâ”€ src/
â”‚  â”‚  â”œâ”€ index.ts
â”‚  â”‚  â”œâ”€ errors/
â”‚  â”‚  â”‚  â””â”€ index.ts  (Day 3 Week 1 å·²å®Œæˆ)
â”‚  â”‚  â”œâ”€ types/
â”‚  â”‚  â”‚  â”œâ”€ index.ts
â”‚  â”‚  â”‚  â”œâ”€ conversation.ts
â”‚  â”‚  â”‚  â”œâ”€ opportunity.ts
â”‚  â”‚  â”‚  â”œâ”€ meddic.ts
â”‚  â”‚  â”‚  â””â”€ slack.ts
â”‚  â”‚  â””â”€ schemas/
â”‚  â”‚     â”œâ”€ index.ts
â”‚  â”‚     â”œâ”€ conversation.ts
â”‚  â”‚     â”œâ”€ opportunity.ts
â”‚  â”‚     â””â”€ meddic.ts
â”‚  â””â”€ dist/
â”œâ”€ services/
â”‚  â””â”€ ... (ä¿æŒä¸è®Š,ä½†ä½¿ç”¨ shared/ çš„é¡å‹)
â”œâ”€ api/
â”‚  â””â”€ ... (ä½¿ç”¨ shared/ çš„ schemas)
â””â”€ db/
   â””â”€ ... (ä¿æŒä¸è®Š)
```

**é—œéµæ–‡ä»¶:**

```typescript
// packages/shared/src/types/conversation.ts
export type ConversationStatus = 'pending' | 'transcribed' | 'completed' | 'failed';

export type ConversationType =
  | 'discovery_call'
  | 'demo'
  | 'negotiation'
  | 'follow_up'
  | 'other';

export interface TranscriptSegment {
  speaker: string;
  text: string;
  start: number;
  end: number;
  confidence?: number;
}

export interface Transcript {
  fullText: string;
  language: string;
  segments: TranscriptSegment[];
  segmentCount?: number;
}

export interface ConversationMetadata {
  fileName: string;
  fileSize: number;
  format: string;
  conversationDate: string;
}

export interface Conversation {
  id: string;
  opportunityId: string;
  caseNumber: string;
  title: string;
  type: ConversationType;
  status: ConversationStatus;
  audioUrl: string;
  transcript: Transcript | null;
  duration: number;
  conversationDate: Date;
  createdBy: string;
  createdAt: Date;
  updatedAt: Date;
  analyzedAt?: Date;
  errorMessage?: string;
}
```

```typescript
// packages/shared/src/schemas/conversation.ts
import { z } from 'zod';

export const conversationStatusSchema = z.enum([
  'pending',
  'transcribed',
  'completed',
  'failed',
]);

export const conversationTypeSchema = z.enum([
  'discovery_call',
  'demo',
  'negotiation',
  'follow_up',
  'other',
]);

export const transcriptSegmentSchema = z.object({
  speaker: z.string(),
  text: z.string(),
  start: z.number(),
  end: z.number(),
  confidence: z.number().optional(),
});

export const transcriptSchema = z.object({
  fullText: z.string(),
  language: z.string(),
  segments: z.array(transcriptSegmentSchema),
  segmentCount: z.number().optional(),
});

export const conversationMetadataSchema = z.object({
  fileName: z.string(),
  fileSize: z.number(),
  format: z.string(),
  conversationDate: z.string(),
});

export const uploadConversationSchema = z.object({
  opportunityId: z.string().uuid(),
  audioBase64: z.string(),
  title: z.string().min(1).max(200),
  type: conversationTypeSchema,
  metadata: conversationMetadataSchema,
});
```

#### Day 4: tRPC è©•ä¼° + POC

**ä»»å‹™æ¸…å–®:**
- [ ] ç ”ç©¶ tRPC vs oRPC å·®ç•°
- [ ] å¯¦ç¾ç°¡å–®çš„ POC (ä¸€å€‹è·¯ç”±)
- [ ] è©•ä¼°é·ç§»æˆæœ¬
- [ ] æ€§èƒ½æ¸¬è©¦å°æ¯”
- [ ] æ±ºç­–æœƒè­°

**POC ç¯„ä¾‹:**

```typescript
// packages/api-trpc/src/index.ts (POC)
import { initTRPC } from '@trpc/server';
import { z } from 'zod';
import type { Env } from './types';

const t = initTRPC.context<{ env: Env }>().create();

export const appRouter = t.router({
  conversations: t.router({
    upload: t.procedure
      .input(z.object({
        opportunityId: z.string(),
        audioBase64: z.string(),
      }))
      .mutation(async ({ input, ctx }) => {
        // å¯¦ç¾é‚è¼¯
        return { conversationId: '...' };
      }),

    analyze: t.procedure
      .input(z.object({
        conversationId: z.string(),
      }))
      .mutation(async ({ input, ctx }) => {
        // å¯¦ç¾é‚è¼¯
        return { status: 'completed' };
      }),
  }),
});

export type AppRouter = typeof appRouter;
```

**è©•ä¼°æ¨™æº–:**

| æŒ‡æ¨™ | oRPC | tRPC | æ¬Šé‡ | è©•åˆ† |
|------|------|------|------|------|
| é¡å‹å®‰å…¨ | âœ… å¥½ | âœ… å„ªç§€ | 30% | ? |
| ç”Ÿæ…‹ç³»çµ± | âš ï¸ æ–° | âœ… æˆç†Ÿ | 25% | ? |
| é·ç§»æˆæœ¬ | - | âš ï¸ é«˜ | 20% | ? |
| æ€§èƒ½ | âœ… å„ªç§€ | âœ… å„ªç§€ | 15% | ? |
| æ–‡æª” | âš ï¸ å°‘ | âœ… è±å¯Œ | 10% | ? |

**æ±ºç­–æ¨™æº–:**
- å¦‚æœç¸½åˆ† > 75% â†’ é·ç§»
- å¦‚æœç¸½åˆ† 50-75% â†’ æ–°å°ˆæ¡ˆä½¿ç”¨,èˆŠå°ˆæ¡ˆä¿ç•™
- å¦‚æœç¸½åˆ† < 50% â†’ ä¿ç•™ oRPC

#### Day 5: æ±ºç­– + æ–‡æª”

**ä»»å‹™æ¸…å–®:**
- [ ] æ•´ç† Week 1-2 æ‰€æœ‰è®Šæ›´
- [ ] æ’°å¯«æ¶æ§‹æ–‡æª”
- [ ] æ›´æ–° README
- [ ] æ±ºå®šæ˜¯å¦é€²è¡Œ tRPC é·ç§»

### 10.5 Week 3: æ¸¬è©¦èˆ‡ä¸Šç·š

#### Day 1-2: å®Œæ•´æ¸¬è©¦

**æ¸¬è©¦è¦†è“‹:**
- [ ] å–®å…ƒæ¸¬è©¦ (80%+ è¦†è“‹ç‡)
- [ ] æ•´åˆæ¸¬è©¦ (é—œéµæµç¨‹)
- [ ] E2E æ¸¬è©¦ (Slack â†’ Queue â†’ é€šçŸ¥)
- [ ] éŒ¯èª¤å ´æ™¯æ¸¬è©¦
- [ ] é‚Šç•Œæ¢ä»¶æ¸¬è©¦

#### Day 3: æ€§èƒ½æ¸¬è©¦

**æ¸¬è©¦å ´æ™¯:**
- [ ] 5MB éŸ³æª” x 10 (ä¸¦ç™¼)
- [ ] 20MB éŸ³æª” x 5 (ä¸¦ç™¼)
- [ ] 96MB éŸ³æª” x 2 (ä¸¦ç™¼)
- [ ] Queue å»¶é²æ¸¬è©¦
- [ ] è³‡æ–™åº«æ€§èƒ½æ¸¬è©¦

#### Day 4: éƒ¨ç½²ç”Ÿç”¢ç’°å¢ƒ

**éƒ¨ç½²æ¸…å–®:**
- [ ] å‚™ä»½è³‡æ–™åº«
- [ ] éƒ¨ç½² Queue Worker
- [ ] éƒ¨ç½² Server (æ›´æ–°)
- [ ] éƒ¨ç½² Slack Bot (æ›´æ–°)
- [ ] æ¸¬è©¦ç”Ÿç”¢ç’°å¢ƒ
- [ ] åˆ‡æ› DNS/æµé‡

#### Day 5: ç›£æ§ + èª¿å„ª

**ç›£æ§æŒ‡æ¨™:**
- [ ] Queue è™•ç†æ™‚é–“
- [ ] æˆåŠŸç‡/å¤±æ•—ç‡
- [ ] Slack é€šçŸ¥é€é”ç‡
- [ ] è³‡æ–™åº«æŸ¥è©¢æ€§èƒ½
- [ ] éŒ¯èª¤æ—¥èªŒåˆ†æ

### 10.6 é©—æ”¶æ¨™æº–

**åŠŸèƒ½é©—æ”¶:**
- âœ… 96MB éŸ³æª”æˆåŠŸè™•ç†
- âœ… Queue é‡è©¦æ©Ÿåˆ¶æ­£å¸¸
- âœ… Slack é€šçŸ¥æ­£å¸¸ç™¼é€
- âœ… è³‡æ–™åº«æ›´æ–°ç©©å®š (ç„¡ NeonDbError)
- âœ… éŒ¯èª¤è¨Šæ¯æ¸…æ™°å‹å–„

**æ€§èƒ½é©—æ”¶:**
- âœ… 5MB éŸ³æª” < 2 åˆ†é˜
- âœ… 20MB éŸ³æª” < 5 åˆ†é˜
- âœ… 96MB éŸ³æª” < 15 åˆ†é˜
- âœ… æ§‹å»ºé€Ÿåº¦æå‡ > 30%

**ä»£ç¢¼å“è³ª:**
- âœ… TypeScript ç„¡éŒ¯èª¤
- âœ… æ¸¬è©¦è¦†è“‹ç‡ > 70%
- âœ… ç„¡ console.log åœ¨ç”Ÿç”¢ç’°å¢ƒ
- âœ… çµ±ä¸€ä½¿ç”¨ AppError

### 10.7 é¢¨éšªèˆ‡æ‡‰å°

| é¢¨éšª | å¯èƒ½æ€§ | å½±éŸ¿ | æ‡‰å°ç­–ç•¥ |
|------|--------|------|---------|
| Queue é…ç½®éŒ¯èª¤ | ä¸­ | é«˜ | è©³ç´°æ–‡æª” + æ¸¬è©¦ç’°å¢ƒé©—è­‰ |
| Neon åœ¨ Queue Worker ä»ä¸ç©©å®š | ä½ | é«˜ | æº–å‚™ D1 é·ç§»è¨ˆåŠƒ (å‚™æ¡ˆ) |
| Slack é€šçŸ¥ç™¼é€å¤±æ•— | ä½ | ä¸­ | é‡è©¦æ©Ÿåˆ¶ + Dead Letter Queue |
| æ€§èƒ½æœªé”æ¨™ | ä½ | ä¸­ | èª¿æ•´ Queue é…ç½® + å„ªåŒ–ä»£ç¢¼ |
| tRPC é·ç§»è¶…æ™‚ | ä¸­ | ä½ | è©•ä¼°å¾Œæ±ºå®šä¸é·ç§» |

### 10.8 æˆåŠŸæŒ‡æ¨™

**çŸ­æœŸ (Week 3 çµæŸ):**
- âœ… 0 æ¬¡å¤§æª”æ¡ˆè¶…æ™‚
- âœ… 0 æ¬¡ NeonDbError
- âœ… 95%+ Slack é€šçŸ¥é€é”ç‡
- âœ… < 5% å¤±æ•—ç‡

**ä¸­æœŸ (ä¸Šç·šå¾Œ 1 å€‹æœˆ):**
- âœ… 99%+ æˆåŠŸç‡
- âœ… < 1% Dead Letter Queue æ¯”ä¾‹
- âœ… æ§‹å»ºæ™‚é–“æ¸›å°‘ 40%+
- âœ… é–‹ç™¼æ•ˆç‡æå‡ 50%+
